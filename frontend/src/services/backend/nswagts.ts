/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.7.0 (NJsonSchema v10.3.9.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthClient {
  private accessToken: string;
  constructor(accessToken: string) {
    this.accessToken = accessToken;
  }

  transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
    if (options.headers && this.accessToken !== null) {
      (<Record<string, string>>options.headers).Authorization =
        "Bearer " + this.accessToken;
      return Promise.resolve(options);
    }
    return Promise.resolve(options);
  }
}

export class ClientBase {
  constructor(private authClient: AuthClient) {}

  private cacheableResponse = false;
  private cacheStrategy: "CacheFirst" | "NetworkFirst" = "NetworkFirst";
  private cacheAllowStatuses: number[] = [200];
  private cacheableOptions: RequestInit = null;

  setCacheableResponse(
    cacheStrategy: ClientBase["cacheStrategy"] = "NetworkFirst",
    cacheAllowStatuses: ClientBase["cacheAllowStatuses"] = [200]
  ) {
    this.cacheableResponse = true;
    this.cacheStrategy = cacheStrategy;
    this.cacheAllowStatuses = cacheAllowStatuses;
  }

  async transformOptions(options: RequestInit): Promise<RequestInit> {
    const result = await (this.authClient
      ? this.authClient.transformHttpRequestOptions(options)
      : Promise.resolve(options));

    if (this.cacheableResponse) {
      this.cacheableOptions = result;
    }

    return result;
  }

  private async cacheResponse(
    request: Request,
    response: Response
  ): Promise<Response> {
    const cache = await caches.open("nswagts.v1");
    const cloned = response.clone();
    await cache.put(request, response);

    return cloned;
  }

  async transformResult(
    url: string,
    networkResponse: Response,
    cb: (response: Response) => any
  ) {
    let response: Response = networkResponse;
    if (process.browser && this.cacheableResponse) {
      console.debug("NswagTs transformResult cacheableResponse executing...");
      const request = new Request(url, this.cacheableOptions);

      const cacheResponse = await caches.match(request);

      const networkOk = this.cacheAllowStatuses.includes(
        networkResponse?.status ?? 0
      );
      const cacheOk = this.cacheAllowStatuses.includes(
        cacheResponse?.status ?? 0
      );

      if (this.cacheStrategy === "CacheFirst") {
        if (cacheOk) {
          console.debug(
            "NswagTs transformResult cacheableResponse cache first using cache",
            cacheResponse
          );
          response = cacheResponse;
        } else {
          console.debug(
            "NswagTs transformResult cacheableResponse cache first using network",
            networkResponse
          );
          response = networkOk
            ? await this.cacheResponse(request, networkResponse)
            : networkResponse;
        }
      } else if (this.cacheStrategy === "NetworkFirst") {
        if (networkOk) {
          console.debug(
            "NswagTs transformResult cacheableResponse network first using network ok",
            networkResponse
          );
          response = await this.cacheResponse(request, networkResponse);
        } else if (cacheOk) {
          console.debug(
            "NswagTs transformResult cacheableResponse network first using cache",
            cacheResponse
          );
          response = cacheResponse;
        } else {
          console.debug(
            "NswagTs transformResult cacheableResponse network first using network failure",
            networkResponse
          );
          response = networkResponse;
        }
      }
    }
    this.cacheableResponse = false;
    return cb(response);
  }
}

export interface IActionClient {
    getAllActions(): Promise<string[]>;
}

export class ActionClient extends ClientBase implements IActionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAllActions(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/Action";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllActions(_response));
        });
    }

    protected processGetAllActions(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export interface IAuthenticationClient {
    login(command: AssignTokenCommand): Promise<UserTokenDto>;
    checkAuth(): Promise<UserIdDto>;
}

export class AuthenticationClient extends ClientBase implements IAuthenticationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(command: AssignTokenCommand): Promise<UserTokenDto> {
        let url_ = this.baseUrl + "/api/Authentication";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogin(_response));
        });
    }

    protected processLogin(response: Response): Promise<UserTokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserTokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserTokenDto>(<any>null);
    }

    checkAuth(): Promise<UserIdDto> {
        let url_ = this.baseUrl + "/api/Authentication/checkauth";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCheckAuth(_response));
        });
    }

    protected processCheckAuth(response: Response): Promise<UserIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserIdDto>(<any>null);
    }
}

export interface ICouponsClient {
    create(command: AssignCouponsCommand): Promise<CouponIdDto[]>;
    invalidateCoupon(couponNumber: number): Promise<CouponIdDto>;
}

export class CouponsClient extends ClientBase implements ICouponsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: AssignCouponsCommand): Promise<CouponIdDto[]> {
        let url_ = this.baseUrl + "/api/Coupons";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<CouponIdDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CouponIdDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CouponIdDto[]>(<any>null);
    }

    invalidateCoupon(couponNumber: number): Promise<CouponIdDto> {
        let url_ = this.baseUrl + "/api/Coupons/{couponNumber}/invalidate";
        if (couponNumber === undefined || couponNumber === null)
            throw new Error("The parameter 'couponNumber' must be defined.");
        url_ = url_.replace("{couponNumber}", encodeURIComponent("" + couponNumber));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processInvalidateCoupon(_response));
        });
    }

    protected processInvalidateCoupon(response: Response): Promise<CouponIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CouponIdDto>(<any>null);
    }
}

export interface IDailyTemperatureClient {
    create(command: CreateDailyTemperatureCommand): Promise<number>;
}

export class DailyTemperatureClient extends ClientBase implements IDailyTemperatureClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateDailyTemperatureCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/DailyTemperature";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface IDebtorClient {
    get(): Promise<DebtorDto[]>;
    printCouponRequired(id: number, command: PrintCouponRequiredCommand): Promise<number>;
}

export class DebtorClient extends ClientBase implements IDebtorClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<DebtorDto[]> {
        let url_ = this.baseUrl + "/api/Debtor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<DebtorDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DebtorDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DebtorDto[]>(<any>null);
    }

    printCouponRequired(id: number, command: PrintCouponRequiredCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Debtor/{id}/CouponRequired";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPrintCouponRequired(_response));
        });
    }

    protected processPrintCouponRequired(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface IExampleEntityClient {
    create(command: CreateExampleEntityCommand): Promise<number>;
    get(needle?: string | null | undefined, size?: number | undefined, sortBy?: string | null | undefined, skip?: number | null | undefined): Promise<PageResultOfExampleEntityDto>;
    update(id: number, command: UpdateExampleEntityCommand): Promise<FileResponse>;
    delete(id: number): Promise<FileResponse>;
}

export class ExampleEntityClient extends ClientBase implements IExampleEntityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateExampleEntityCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/ExampleEntity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    get(needle?: string | null | undefined, size?: number | undefined, sortBy?: string | null | undefined, skip?: number | null | undefined): Promise<PageResultOfExampleEntityDto> {
        let url_ = this.baseUrl + "/api/ExampleEntity?";
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "sortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<PageResultOfExampleEntityDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfExampleEntityDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfExampleEntityDto>(<any>null);
    }

    update(id: number, command: UpdateExampleEntityCommand): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/ExampleEntity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdate(_response));
        });
    }

    protected processUpdate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    delete(id: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/ExampleEntity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDelete(_response));
        });
    }

    protected processDelete(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface IExampleEntityListClient {
    create(command: CreateExampleEntityListCommand): Promise<number>;
}

export class ExampleEntityListClient extends ClientBase implements IExampleEntityListClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateExampleEntityListCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/ExampleEntityList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface IHealthClient {
    get(): Promise<boolean>;
}

export class HealthClient extends ClientBase implements IHealthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Promise<boolean> {
        let url_ = this.baseUrl + "/api/Health";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export interface ILocationClient {
    addNewLocation(command: CreateLocationCommand): Promise<number>;
    getAll(locationType?: TankType | null | undefined, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfLocationDetailsIdDtoAndDateTimeOffset>;
    addDebtor(command: AddDebtorToLocationCommand): Promise<number>;
    updateDebtor(command: UpdateDebtorOnLocationCommand): Promise<number>;
    removeDebtor(command: RemoveDebtorFromLocationCommand): Promise<number>;
    getLocationHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfLocationHistoryDto>;
    getDebtorHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfLocationDebtorHistoryDtoAndDateTime>;
    getRefillHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfRefillDtoAndDateTimeOffset>;
    updateMetaData(id: number, command: UpdateLocationMetaDataCommand): Promise<number>;
    saveLocationImage(id: number, file?: FileParameter | null | undefined): Promise<string>;
    getLocationImage(id: number): Promise<ImageResponseDto[]>;
}

export class LocationClient extends ClientBase implements ILocationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addNewLocation(command: CreateLocationCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddNewLocation(_response));
        });
    }

    protected processAddNewLocation(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    getAll(locationType?: TankType | null | undefined, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfLocationDetailsIdDtoAndDateTimeOffset> {
        let url_ = this.baseUrl + "/api/Location?";
        if (locationType !== undefined && locationType !== null)
            url_ += "locationType=" + encodeURIComponent("" + locationType) + "&";
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent(needle ? "" + needle.toJSON() : "") + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<PageResultOfLocationDetailsIdDtoAndDateTimeOffset> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfLocationDetailsIdDtoAndDateTimeOffset.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfLocationDetailsIdDtoAndDateTimeOffset>(<any>null);
    }

    addDebtor(command: AddDebtorToLocationCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Location/addDebtor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAddDebtor(_response));
        });
    }

    protected processAddDebtor(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    updateDebtor(command: UpdateDebtorOnLocationCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Location/updateDebtor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateDebtor(_response));
        });
    }

    protected processUpdateDebtor(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    removeDebtor(command: RemoveDebtorFromLocationCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Location/removeDebtor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processRemoveDebtor(_response));
        });
    }

    protected processRemoveDebtor(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    getLocationHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfLocationHistoryDto> {
        let url_ = this.baseUrl + "/api/Location/{id}/history?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent(needle ? "" + needle.toJSON() : "") + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLocationHistory(_response));
        });
    }

    protected processGetLocationHistory(response: Response): Promise<PageResultOfLocationHistoryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfLocationHistoryDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfLocationHistoryDto>(<any>null);
    }

    getDebtorHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfLocationDebtorHistoryDtoAndDateTime> {
        let url_ = this.baseUrl + "/api/Location/{id}/debtorHistory?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent(needle ? "" + needle.toJSON() : "") + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetDebtorHistory(_response));
        });
    }

    protected processGetDebtorHistory(response: Response): Promise<PageResultOfLocationDebtorHistoryDtoAndDateTime> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfLocationDebtorHistoryDtoAndDateTime.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfLocationDebtorHistoryDtoAndDateTime>(<any>null);
    }

    getRefillHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfRefillDtoAndDateTimeOffset> {
        let url_ = this.baseUrl + "/api/Location/{id}/refillHistory?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent(needle ? "" + needle.toJSON() : "") + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRefillHistory(_response));
        });
    }

    protected processGetRefillHistory(response: Response): Promise<PageResultOfRefillDtoAndDateTimeOffset> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfRefillDtoAndDateTimeOffset.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfRefillDtoAndDateTimeOffset>(<any>null);
    }

    updateMetaData(id: number, command: UpdateLocationMetaDataCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateMetaData(_response));
        });
    }

    protected processUpdateMetaData(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    saveLocationImage(id: number, file?: FileParameter | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSaveLocationImage(_response));
        });
    }

    protected processSaveLocationImage(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    getLocationImage(id: number): Promise<ImageResponseDto[]> {
        let url_ = this.baseUrl + "/api/Location/{id}/image";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetLocationImage(_response));
        });
    }

    protected processGetLocationImage(response: Response): Promise<ImageResponseDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImageResponseDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImageResponseDto[]>(<any>null);
    }
}

export interface IRefillClient {
    complete(id: number, command: CompleteRefillCommand): Promise<number>;
    get(needle?: string | null | undefined, size?: number | undefined, skip?: number | null | undefined, tankType?: TankType | null | undefined): Promise<PageResultOfRefillDto>;
    orderRefill(command: OrderRefillCommand): Promise<number>;
    saveCouponImage(id: number, file?: FileParameter | null | undefined): Promise<CouponImageInfoDto>;
    getCouponImage(id: number): Promise<ImageResponseDto2[]>;
}

export class RefillClient extends ClientBase implements IRefillClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    complete(id: number, command: CompleteRefillCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Refill/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processComplete(_response));
        });
    }

    protected processComplete(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    get(needle?: string | null | undefined, size?: number | undefined, skip?: number | null | undefined, tankType?: TankType | null | undefined): Promise<PageResultOfRefillDto> {
        let url_ = this.baseUrl + "/api/Refill?";
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (tankType !== undefined && tankType !== null)
            url_ += "tankType=" + encodeURIComponent("" + tankType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<PageResultOfRefillDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfRefillDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfRefillDto>(<any>null);
    }

    orderRefill(command: OrderRefillCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Refill";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processOrderRefill(_response));
        });
    }

    protected processOrderRefill(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    saveCouponImage(id: number, file?: FileParameter | null | undefined): Promise<CouponImageInfoDto> {
        let url_ = this.baseUrl + "/api/Refill/{id}/image";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processSaveCouponImage(_response));
        });
    }

    protected processSaveCouponImage(response: Response): Promise<CouponImageInfoDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CouponImageInfoDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CouponImageInfoDto>(<any>null);
    }

    getCouponImage(id: number): Promise<ImageResponseDto2[]> {
        let url_ = this.baseUrl + "/api/Refill/{id}/image";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCouponImage(_response));
        });
    }

    protected processGetCouponImage(response: Response): Promise<ImageResponseDto2[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ImageResponseDto2.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ImageResponseDto2[]>(<any>null);
    }
}

export interface IRoleClient {
    createRole(command: CreateRoleCommand): Promise<RoleIdDto>;
    updateRole(command: UpdateRoleCommand): Promise<RoleIdDto>;
    getRole(id: number): Promise<RoleIdDto>;
    getAllRole(needle?: string | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfRoleIdDtoAndString>;
}

export class RoleClient extends ClientBase implements IRoleClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createRole(command: CreateRoleCommand): Promise<RoleIdDto> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateRole(_response));
        });
    }

    protected processCreateRole(response: Response): Promise<RoleIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleIdDto>(<any>null);
    }

    updateRole(command: UpdateRoleCommand): Promise<RoleIdDto> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateRole(_response));
        });
    }

    protected processUpdateRole(response: Response): Promise<RoleIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleIdDto>(<any>null);
    }

    getRole(id: number): Promise<RoleIdDto> {
        let url_ = this.baseUrl + "/api/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRole(_response));
        });
    }

    protected processGetRole(response: Response): Promise<RoleIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RoleIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RoleIdDto>(<any>null);
    }

    getAllRole(needle?: string | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfRoleIdDtoAndString> {
        let url_ = this.baseUrl + "/api/Role/AllRoles?";
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllRole(_response));
        });
    }

    protected processGetAllRole(response: Response): Promise<PageResultOfRoleIdDtoAndString> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfRoleIdDtoAndString.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfRoleIdDtoAndString>(<any>null);
    }
}

export interface IStatsClient {
    getRefillOfYearFile(year?: number | undefined): Promise<FileResponse>;
    getUsageHistoryFile(locationId?: number | undefined, interval?: Interval | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Promise<FileResponse>;
    getUsageHistory(locationId?: number | undefined, interval?: Interval | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Promise<FuelConsumptionDto[]>;
}

export class StatsClient extends ClientBase implements IStatsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRefillOfYearFile(year?: number | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Stats/refillHistoryFile?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRefillOfYearFile(_response));
        });
    }

    protected processGetRefillOfYearFile(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getUsageHistoryFile(locationId?: number | undefined, interval?: Interval | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Stats/usageHistoryFile?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (interval === null)
            throw new Error("The parameter 'interval' cannot be null.");
        else if (interval !== undefined)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUsageHistoryFile(_response));
        });
    }

    protected processGetUsageHistoryFile(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getUsageHistory(locationId?: number | undefined, interval?: Interval | undefined, startDate?: Date | undefined, endDate?: Date | undefined): Promise<FuelConsumptionDto[]> {
        let url_ = this.baseUrl + "/api/Stats/usageHistory?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        if (interval === null)
            throw new Error("The parameter 'interval' cannot be null.");
        else if (interval !== undefined)
            url_ += "interval=" + encodeURIComponent("" + interval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetUsageHistory(_response));
        });
    }

    protected processGetUsageHistory(response: Response): Promise<FuelConsumptionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FuelConsumptionDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FuelConsumptionDto[]>(<any>null);
    }
}

export interface IStreetClient {
    get(needle?: string | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfStreetDto>;
}

export class StreetClient extends ClientBase implements IStreetClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(needle?: string | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfStreetDto> {
        let url_ = this.baseUrl + "/api/Street?";
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<PageResultOfStreetDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfStreetDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfStreetDto>(<any>null);
    }
}

export interface ITruckClient {
    getTruck(id: number): Promise<TruckInfoDetailsDto>;
    updateTruck(id: number, command: UpdateTruckCommand): Promise<TruckInfoIdDto>;
    getTrucksCoupons(id: number, needle?: number | null | undefined, size?: number | undefined, skip?: number | null | undefined, includeDestroyedCoupons?: boolean | null | undefined): Promise<PageResultOfCouponIdDtoAndInteger>;
    getTrucks(needle?: number | undefined, size?: number | undefined, skip?: number | undefined): Promise<PageResultOfTruckInfoIdDtoAndInteger>;
    createTruck(command: CreateTruckCommand): Promise<TruckInfoIdDto>;
    getTrucksRefills(id: number): Promise<LocationRefillDto[]>;
    getRefillHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfRefillDtoAndDateTimeOffset>;
    createTruckRefuel(id: number, command: CreateTruckRefillCommand): Promise<number>;
}

export class TruckClient extends ClientBase implements ITruckClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTruck(id: number): Promise<TruckInfoDetailsDto> {
        let url_ = this.baseUrl + "/api/Truck/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTruck(_response));
        });
    }

    protected processGetTruck(response: Response): Promise<TruckInfoDetailsDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TruckInfoDetailsDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TruckInfoDetailsDto>(<any>null);
    }

    updateTruck(id: number, command: UpdateTruckCommand): Promise<TruckInfoIdDto> {
        let url_ = this.baseUrl + "/api/Truck/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateTruck(_response));
        });
    }

    protected processUpdateTruck(response: Response): Promise<TruckInfoIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TruckInfoIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TruckInfoIdDto>(<any>null);
    }

    getTrucksCoupons(id: number, needle?: number | null | undefined, size?: number | undefined, skip?: number | null | undefined, includeDestroyedCoupons?: boolean | null | undefined): Promise<PageResultOfCouponIdDtoAndInteger> {
        let url_ = this.baseUrl + "/api/Truck/{id}/coupons?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (includeDestroyedCoupons !== undefined && includeDestroyedCoupons !== null)
            url_ += "includeDestroyedCoupons=" + encodeURIComponent("" + includeDestroyedCoupons) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTrucksCoupons(_response));
        });
    }

    protected processGetTrucksCoupons(response: Response): Promise<PageResultOfCouponIdDtoAndInteger> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfCouponIdDtoAndInteger.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfCouponIdDtoAndInteger>(<any>null);
    }

    getTrucks(needle?: number | undefined, size?: number | undefined, skip?: number | undefined): Promise<PageResultOfTruckInfoIdDtoAndInteger> {
        let url_ = this.baseUrl + "/api/Truck?";
        if (needle === null)
            throw new Error("The parameter 'needle' cannot be null.");
        else if (needle !== undefined)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTrucks(_response));
        });
    }

    protected processGetTrucks(response: Response): Promise<PageResultOfTruckInfoIdDtoAndInteger> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfTruckInfoIdDtoAndInteger.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfTruckInfoIdDtoAndInteger>(<any>null);
    }

    createTruck(command: CreateTruckCommand): Promise<TruckInfoIdDto> {
        let url_ = this.baseUrl + "/api/Truck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateTruck(_response));
        });
    }

    protected processCreateTruck(response: Response): Promise<TruckInfoIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TruckInfoIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TruckInfoIdDto>(<any>null);
    }

    getTrucksRefills(id: number): Promise<LocationRefillDto[]> {
        let url_ = this.baseUrl + "/api/Truck/{id}/runList";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetTrucksRefills(_response));
        });
    }

    protected processGetTrucksRefills(response: Response): Promise<LocationRefillDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LocationRefillDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LocationRefillDto[]>(<any>null);
    }

    getRefillHistory(id: number, needle?: Date | null | undefined, size?: number | undefined, skip?: number | null | undefined): Promise<PageResultOfRefillDtoAndDateTimeOffset> {
        let url_ = this.baseUrl + "/api/Truck/{id}/refillHistory?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (needle !== undefined && needle !== null)
            url_ += "needle=" + encodeURIComponent(needle ? "" + needle.toJSON() : "") + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip !== undefined && skip !== null)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetRefillHistory(_response));
        });
    }

    protected processGetRefillHistory(response: Response): Promise<PageResultOfRefillDtoAndDateTimeOffset> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfRefillDtoAndDateTimeOffset.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfRefillDtoAndDateTimeOffset>(<any>null);
    }

    createTruckRefuel(id: number, command: CreateTruckRefillCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Truck/{id}/refuel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateTruckRefuel(_response));
        });
    }

    protected processCreateTruckRefuel(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface IUserClient {
    createUser(command: CreateUserCommand): Promise<number>;
    getAllUser(needle?: number | undefined, size?: number | undefined, skip?: number | undefined): Promise<PageResultOfUserIdDtoAndInteger>;
    updateUserRoles(id: number, command: UpdateUserRolesCommand): Promise<UserIdDto>;
    updateUserPassword(id: number, command: UpdatePasswordCommand): Promise<number>;
    deleteUser(id: number): Promise<UserDto>;
}

export class UserClient extends ClientBase implements IUserClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createUser(command: CreateUserCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreateUser(_response));
        });
    }

    protected processCreateUser(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    getAllUser(needle?: number | undefined, size?: number | undefined, skip?: number | undefined): Promise<PageResultOfUserIdDtoAndInteger> {
        let url_ = this.baseUrl + "/api/User?";
        if (needle === null)
            throw new Error("The parameter 'needle' cannot be null.");
        else if (needle !== undefined)
            url_ += "needle=" + encodeURIComponent("" + needle) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAllUser(_response));
        });
    }

    protected processGetAllUser(response: Response): Promise<PageResultOfUserIdDtoAndInteger> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PageResultOfUserIdDtoAndInteger.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PageResultOfUserIdDtoAndInteger>(<any>null);
    }

    updateUserRoles(id: number, command: UpdateUserRolesCommand): Promise<UserIdDto> {
        let url_ = this.baseUrl + "/api/User/{id}/role";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateUserRoles(_response));
        });
    }

    protected processUpdateUserRoles(response: Response): Promise<UserIdDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserIdDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserIdDto>(<any>null);
    }

    updateUserPassword(id: number, command: UpdatePasswordCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/User/{id}/password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUpdateUserPassword(_response));
        });
    }

    protected processUpdateUserPassword(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    deleteUser(id: number): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/User/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDeleteUser(_response));
        });
    }

    protected processDeleteUser(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(<any>null);
    }
}

export class UserTokenDto implements IUserTokenDto {
    user?: UserIdDto | null;
    token?: string | null;

    constructor(data?: IUserTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.user = data.user && !(<any>data.user).toJSON ? new UserIdDto(data.user) : <UserIdDto>this.user; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserIdDto.fromJS(_data["user"]) : <any>null;
            this.token = _data["token"] !== undefined ? _data["token"] : <any>null;
        }
    }

    static fromJS(data: any): UserTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>null;
        data["token"] = this.token !== undefined ? this.token : <any>null;
        return data; 
    }
}

export interface IUserTokenDto {
    user?: IUserIdDto | null;
    token?: string | null;
}

export class UserDto implements IUserDto {
    username?: string | null;
    truckId?: number | null;
    currentRole?: RoleIdDto | null;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.currentRole = data.currentRole && !(<any>data.currentRole).toJSON ? new RoleIdDto(data.currentRole) : <RoleIdDto>this.currentRole; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.truckId = _data["truckId"] !== undefined ? _data["truckId"] : <any>null;
            this.currentRole = _data["currentRole"] ? RoleIdDto.fromJS(_data["currentRole"]) : <any>null;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["truckId"] = this.truckId !== undefined ? this.truckId : <any>null;
        data["currentRole"] = this.currentRole ? this.currentRole.toJSON() : <any>null;
        return data; 
    }
}

export interface IUserDto {
    username?: string | null;
    truckId?: number | null;
    currentRole?: IRoleIdDto | null;
}

export class UserIdDto extends UserDto implements IUserIdDto {
    id?: number;
    isTrucker?: boolean;

    constructor(data?: IUserIdDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.isTrucker = _data["isTrucker"] !== undefined ? _data["isTrucker"] : <any>null;
        }
    }

    static fromJS(data: any): UserIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["isTrucker"] = this.isTrucker !== undefined ? this.isTrucker : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IUserIdDto extends IUserDto {
    id?: number;
    isTrucker?: boolean;
}

export class RoleDto implements IRoleDto {
    name?: string | null;
    actions?: Action[] | null;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            if (Array.isArray(_data["actions"])) {
                this.actions = [] as any;
                for (let item of _data["actions"])
                    this.actions!.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (Array.isArray(this.actions)) {
            data["actions"] = [];
            for (let item of this.actions)
                data["actions"].push(item);
        }
        return data; 
    }
}

export interface IRoleDto {
    name?: string | null;
    actions?: Action[] | null;
}

export class RoleIdDto extends RoleDto implements IRoleIdDto {
    id?: number;

    constructor(data?: IRoleIdDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): RoleIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface IRoleIdDto extends IRoleDto {
    id?: number;
}

export enum Action {
    ASSIGN_COUPON = 0,
    SAVE_COUPON_IMAGE = 1,
    UPDATE_COUPON_STATUS = 2,
    GET_COUPONS = 3,
    SET_TEMPERATURE = 4,
    GET_DEBTOR = 5,
    GET_LOCATION_HISTORIES = 6,
    CREATE_LOCATION = 7,
    UPDATE_LOCATION = 8,
    GET_LOCATION = 9,
    CREATE_REFILL = 10,
    ORDER_REFILL = 11,
    GET_REFILLS = 12,
    GET_STREETS = 13,
    CREATE_TRUCK_REFILL = 14,
    CREATE_TRUCK = 15,
    UPDATE_TRUCK = 16,
    GET_TRUCK = 17,
    GET_ROLES = 18,
    UPDATE_USER = 19,
    GET_ALL_USERS = 20,
    SET_DEBTOR_COUPON_REQUIRED = 21,
    CREATE_ROLE = 22,
    UPDATE_ROLE = 23,
    DELETE_USER = 24,
    CREATE_USER = 25,
}

export class AssignTokenCommand implements IAssignTokenCommand {
    username?: string | null;
    password?: string | null;

    constructor(data?: IAssignTokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"] !== undefined ? _data["username"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): AssignTokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignTokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IAssignTokenCommand {
    username?: string | null;
    password?: string | null;
}

export class CouponDto implements ICouponDto {
    couponNumber?: number;
    truckId?: number;
    status?: CouponStatus;

    constructor(data?: ICouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.couponNumber = _data["couponNumber"] !== undefined ? _data["couponNumber"] : <any>null;
            this.truckId = _data["truckId"] !== undefined ? _data["truckId"] : <any>null;
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
        }
    }

    static fromJS(data: any): CouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["couponNumber"] = this.couponNumber !== undefined ? this.couponNumber : <any>null;
        data["truckId"] = this.truckId !== undefined ? this.truckId : <any>null;
        data["status"] = this.status !== undefined ? this.status : <any>null;
        return data; 
    }
}

export interface ICouponDto {
    couponNumber?: number;
    truckId?: number;
    status?: CouponStatus;
}

export class CouponIdDto extends CouponDto implements ICouponIdDto {
    id?: number;

    constructor(data?: ICouponIdDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): CouponIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ICouponIdDto extends ICouponDto {
    id?: number;
}

export enum CouponStatus {
    AVAILABLE = 0,
    USED = 1,
    DESTROYED = 2,
}

export class AssignCouponsCommand implements IAssignCouponsCommand {
    dto?: AssignCouponDto | null;

    constructor(data?: IAssignCouponsCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.dto = data.dto && !(<any>data.dto).toJSON ? new AssignCouponDto(data.dto) : <AssignCouponDto>this.dto; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dto = _data["dto"] ? AssignCouponDto.fromJS(_data["dto"]) : <any>null;
        }
    }

    static fromJS(data: any): AssignCouponsCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignCouponsCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dto"] = this.dto ? this.dto.toJSON() : <any>null;
        return data; 
    }
}

export interface IAssignCouponsCommand {
    dto?: IAssignCouponDto | null;
}

export class AssignCouponDto implements IAssignCouponDto {
    truckId?: number;
    couponNumbers?: number[] | null;

    constructor(data?: IAssignCouponDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.truckId = _data["truckId"] !== undefined ? _data["truckId"] : <any>null;
            if (Array.isArray(_data["couponNumbers"])) {
                this.couponNumbers = [] as any;
                for (let item of _data["couponNumbers"])
                    this.couponNumbers!.push(item);
            }
        }
    }

    static fromJS(data: any): AssignCouponDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignCouponDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truckId"] = this.truckId !== undefined ? this.truckId : <any>null;
        if (Array.isArray(this.couponNumbers)) {
            data["couponNumbers"] = [];
            for (let item of this.couponNumbers)
                data["couponNumbers"].push(item);
        }
        return data; 
    }
}

export interface IAssignCouponDto {
    truckId?: number;
    couponNumbers?: number[] | null;
}

export class CreateDailyTemperatureCommand implements ICreateDailyTemperatureCommand {
    regionId?: number;
    date?: Date;
    temperature?: number;

    constructor(data?: ICreateDailyTemperatureCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.temperature = _data["temperature"] !== undefined ? _data["temperature"] : <any>null;
        }
    }

    static fromJS(data: any): CreateDailyTemperatureCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDailyTemperatureCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["temperature"] = this.temperature !== undefined ? this.temperature : <any>null;
        return data; 
    }
}

export interface ICreateDailyTemperatureCommand {
    regionId?: number;
    date?: Date;
    temperature?: number;
}

export class DebtorDto implements IDebtorDto {
    id?: number;
    unicontaId?: number;
    blocked?: boolean;
    accountNumber?: string | null;
    name?: string | null;
    gln?: string | null;
    couponRequired?: boolean;

    constructor(data?: IDebtorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.unicontaId = _data["unicontaId"] !== undefined ? _data["unicontaId"] : <any>null;
            this.blocked = _data["blocked"] !== undefined ? _data["blocked"] : <any>null;
            this.accountNumber = _data["accountNumber"] !== undefined ? _data["accountNumber"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.gln = _data["gln"] !== undefined ? _data["gln"] : <any>null;
            this.couponRequired = _data["couponRequired"] !== undefined ? _data["couponRequired"] : <any>null;
        }
    }

    static fromJS(data: any): DebtorDto {
        data = typeof data === 'object' ? data : {};
        let result = new DebtorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["unicontaId"] = this.unicontaId !== undefined ? this.unicontaId : <any>null;
        data["blocked"] = this.blocked !== undefined ? this.blocked : <any>null;
        data["accountNumber"] = this.accountNumber !== undefined ? this.accountNumber : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["gln"] = this.gln !== undefined ? this.gln : <any>null;
        data["couponRequired"] = this.couponRequired !== undefined ? this.couponRequired : <any>null;
        return data; 
    }
}

export interface IDebtorDto {
    id?: number;
    unicontaId?: number;
    blocked?: boolean;
    accountNumber?: string | null;
    name?: string | null;
    gln?: string | null;
    couponRequired?: boolean;
}

export class PrintCouponRequiredCommand implements IPrintCouponRequiredCommand {
    debtorId?: number;
    printCouponRequired?: boolean;

    constructor(data?: IPrintCouponRequiredCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.debtorId = _data["debtorId"] !== undefined ? _data["debtorId"] : <any>null;
            this.printCouponRequired = _data["printCouponRequired"] !== undefined ? _data["printCouponRequired"] : <any>null;
        }
    }

    static fromJS(data: any): PrintCouponRequiredCommand {
        data = typeof data === 'object' ? data : {};
        let result = new PrintCouponRequiredCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["debtorId"] = this.debtorId !== undefined ? this.debtorId : <any>null;
        data["printCouponRequired"] = this.printCouponRequired !== undefined ? this.printCouponRequired : <any>null;
        return data; 
    }
}

export interface IPrintCouponRequiredCommand {
    debtorId?: number;
    printCouponRequired?: boolean;
}

export class CreateExampleEntityCommand implements ICreateExampleEntityCommand {
    name?: string | null;
    exampleEnum?: ExampleEnum;

    constructor(data?: ICreateExampleEntityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.exampleEnum = _data["exampleEnum"] !== undefined ? _data["exampleEnum"] : <any>null;
        }
    }

    static fromJS(data: any): CreateExampleEntityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExampleEntityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["exampleEnum"] = this.exampleEnum !== undefined ? this.exampleEnum : <any>null;
        return data; 
    }
}

export interface ICreateExampleEntityCommand {
    name?: string | null;
    exampleEnum?: ExampleEnum;
}

export enum ExampleEnum {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
}

export class UpdateExampleEntityCommand implements IUpdateExampleEntityCommand {
    id?: number;
    name?: string | null;
    exampleEnum?: ExampleEnum;
    exampleEntityListId?: number | null;

    constructor(data?: IUpdateExampleEntityCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.exampleEnum = _data["exampleEnum"] !== undefined ? _data["exampleEnum"] : <any>null;
            this.exampleEntityListId = _data["exampleEntityListId"] !== undefined ? _data["exampleEntityListId"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateExampleEntityCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExampleEntityCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["exampleEnum"] = this.exampleEnum !== undefined ? this.exampleEnum : <any>null;
        data["exampleEntityListId"] = this.exampleEntityListId !== undefined ? this.exampleEntityListId : <any>null;
        return data; 
    }
}

export interface IUpdateExampleEntityCommand {
    id?: number;
    name?: string | null;
    exampleEnum?: ExampleEnum;
    exampleEntityListId?: number | null;
}

export class PageResultOfExampleEntityDtoAndString implements IPageResultOfExampleEntityDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: ExampleEntityDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfExampleEntityDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new ExampleEntityDto(item) : <ExampleEntityDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ExampleEntityDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfExampleEntityDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfExampleEntityDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfExampleEntityDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: IExampleEntityDto[] | null;
    hasMore?: boolean;
}

export class PageResultOfExampleEntityDto extends PageResultOfExampleEntityDtoAndString implements IPageResultOfExampleEntityDto {

    constructor(data?: IPageResultOfExampleEntityDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PageResultOfExampleEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfExampleEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPageResultOfExampleEntityDto extends IPageResultOfExampleEntityDtoAndString {
}

export class ExampleEntityDto implements IExampleEntityDto {
    id?: number;
    name?: string | null;
    exampleEnum?: ExampleEnum;
    createdAt?: string | null;
    updatedAt?: string | null;

    constructor(data?: IExampleEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.exampleEnum = _data["exampleEnum"] !== undefined ? _data["exampleEnum"] : <any>null;
            this.createdAt = _data["createdAt"] !== undefined ? _data["createdAt"] : <any>null;
            this.updatedAt = _data["updatedAt"] !== undefined ? _data["updatedAt"] : <any>null;
        }
    }

    static fromJS(data: any): ExampleEntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExampleEntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["exampleEnum"] = this.exampleEnum !== undefined ? this.exampleEnum : <any>null;
        data["createdAt"] = this.createdAt !== undefined ? this.createdAt : <any>null;
        data["updatedAt"] = this.updatedAt !== undefined ? this.updatedAt : <any>null;
        return data; 
    }
}

export interface IExampleEntityDto {
    id?: number;
    name?: string | null;
    exampleEnum?: ExampleEnum;
    createdAt?: string | null;
    updatedAt?: string | null;
}

export class CreateExampleEntityListCommand implements ICreateExampleEntityListCommand {
    name?: string | null;

    constructor(data?: ICreateExampleEntityListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
        }
    }

    static fromJS(data: any): CreateExampleEntityListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExampleEntityListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data; 
    }
}

export interface ICreateExampleEntityListCommand {
    name?: string | null;
}

export class CreateLocationCommand implements ICreateLocationCommand {
    data?: LocationDetailsDto | null;

    constructor(data?: ICreateLocationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new LocationDetailsDto(data.data) : <LocationDetailsDto>this.data; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LocationDetailsDto.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): CreateLocationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLocationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface ICreateLocationCommand {
    data?: ILocationDetailsDto | null;
}

export class LocationDto implements ILocationDto {
    address?: string | null;
    addressExtra?: string | null;
    comments?: string | null;
    regionId?: number;
    schedule?: RefillSchedule;
    estimateFuelConsumption?: number;
    daysBetweenRefills?: number;
    mainDebtorId?: number | null;
    baseDebtorId?: number | null;
    upcomingDebtorId?: number | null;
    inactiveSince?: Date | null;
    debtorChangeDate?: Date | null;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.addressExtra = _data["addressExtra"] !== undefined ? _data["addressExtra"] : <any>null;
            this.comments = _data["comments"] !== undefined ? _data["comments"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.schedule = _data["schedule"] !== undefined ? _data["schedule"] : <any>null;
            this.estimateFuelConsumption = _data["estimateFuelConsumption"] !== undefined ? _data["estimateFuelConsumption"] : <any>null;
            this.daysBetweenRefills = _data["daysBetweenRefills"] !== undefined ? _data["daysBetweenRefills"] : <any>null;
            this.mainDebtorId = _data["mainDebtorId"] !== undefined ? _data["mainDebtorId"] : <any>null;
            this.baseDebtorId = _data["baseDebtorId"] !== undefined ? _data["baseDebtorId"] : <any>null;
            this.upcomingDebtorId = _data["upcomingDebtorId"] !== undefined ? _data["upcomingDebtorId"] : <any>null;
            this.inactiveSince = _data["inactiveSince"] ? new Date(_data["inactiveSince"].toString()) : <any>null;
            this.debtorChangeDate = _data["debtorChangeDate"] ? new Date(_data["debtorChangeDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["addressExtra"] = this.addressExtra !== undefined ? this.addressExtra : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["schedule"] = this.schedule !== undefined ? this.schedule : <any>null;
        data["estimateFuelConsumption"] = this.estimateFuelConsumption !== undefined ? this.estimateFuelConsumption : <any>null;
        data["daysBetweenRefills"] = this.daysBetweenRefills !== undefined ? this.daysBetweenRefills : <any>null;
        data["mainDebtorId"] = this.mainDebtorId !== undefined ? this.mainDebtorId : <any>null;
        data["baseDebtorId"] = this.baseDebtorId !== undefined ? this.baseDebtorId : <any>null;
        data["upcomingDebtorId"] = this.upcomingDebtorId !== undefined ? this.upcomingDebtorId : <any>null;
        data["inactiveSince"] = this.inactiveSince ? this.inactiveSince.toISOString() : <any>null;
        data["debtorChangeDate"] = this.debtorChangeDate ? this.debtorChangeDate.toISOString() : <any>null;
        return data; 
    }
}

export interface ILocationDto {
    address?: string | null;
    addressExtra?: string | null;
    comments?: string | null;
    regionId?: number;
    schedule?: RefillSchedule;
    estimateFuelConsumption?: number;
    daysBetweenRefills?: number;
    mainDebtorId?: number | null;
    baseDebtorId?: number | null;
    upcomingDebtorId?: number | null;
    inactiveSince?: Date | null;
    debtorChangeDate?: Date | null;
}

export class LocationDetailsDto extends LocationDto implements ILocationDetailsDto {
    tankType?: TankType;
    bstNumber?: string | null;
    tankCapacity?: number;
    minimumFuelAmount?: number;
    fuelType?: FuelType;

    constructor(data?: ILocationDetailsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.tankType = _data["tankType"] !== undefined ? _data["tankType"] : <any>null;
            this.bstNumber = _data["bstNumber"] !== undefined ? _data["bstNumber"] : <any>null;
            this.tankCapacity = _data["tankCapacity"] !== undefined ? _data["tankCapacity"] : <any>null;
            this.minimumFuelAmount = _data["minimumFuelAmount"] !== undefined ? _data["minimumFuelAmount"] : <any>null;
            this.fuelType = _data["fuelType"] !== undefined ? _data["fuelType"] : <any>null;
        }
    }

    static fromJS(data: any): LocationDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tankType"] = this.tankType !== undefined ? this.tankType : <any>null;
        data["bstNumber"] = this.bstNumber !== undefined ? this.bstNumber : <any>null;
        data["tankCapacity"] = this.tankCapacity !== undefined ? this.tankCapacity : <any>null;
        data["minimumFuelAmount"] = this.minimumFuelAmount !== undefined ? this.minimumFuelAmount : <any>null;
        data["fuelType"] = this.fuelType !== undefined ? this.fuelType : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ILocationDetailsDto extends ILocationDto {
    tankType?: TankType;
    bstNumber?: string | null;
    tankCapacity?: number;
    minimumFuelAmount?: number;
    fuelType?: FuelType;
}

export enum TankType {
    BUILDING = 0,
    SHIP = 1,
    TANK = 2,
}

export enum FuelType {
    OIL = 0,
    PETROLEUM = 1,
    GASOLINE = 2,
    OTHER = 3,
}

export enum RefillSchedule {
    AUTOMATIC = 0,
    INTERVAL = 1,
    MANUAL = 2,
}

export class AddDebtorToLocationCommand implements IAddDebtorToLocationCommand {
    locationId?: number;
    debtorId?: number;
    debtorType?: LocationDebtorType;
    changeDate?: Date | null;

    constructor(data?: IAddDebtorToLocationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.debtorId = _data["debtorId"] !== undefined ? _data["debtorId"] : <any>null;
            this.debtorType = _data["debtorType"] !== undefined ? _data["debtorType"] : <any>null;
            this.changeDate = _data["changeDate"] ? new Date(_data["changeDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): AddDebtorToLocationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddDebtorToLocationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["debtorId"] = this.debtorId !== undefined ? this.debtorId : <any>null;
        data["debtorType"] = this.debtorType !== undefined ? this.debtorType : <any>null;
        data["changeDate"] = this.changeDate ? this.changeDate.toISOString() : <any>null;
        return data; 
    }
}

export interface IAddDebtorToLocationCommand {
    locationId?: number;
    debtorId?: number;
    debtorType?: LocationDebtorType;
    changeDate?: Date | null;
}

export enum LocationDebtorType {
    MAIN = 0,
    BASE = 1,
    UPCOMING = 2,
}

export class UpdateDebtorOnLocationCommand implements IUpdateDebtorOnLocationCommand {
    locationId?: number;
    debtorId?: number;
    debtorType?: LocationDebtorType;
    changeDate?: Date | null;

    constructor(data?: IUpdateDebtorOnLocationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.debtorId = _data["debtorId"] !== undefined ? _data["debtorId"] : <any>null;
            this.debtorType = _data["debtorType"] !== undefined ? _data["debtorType"] : <any>null;
            this.changeDate = _data["changeDate"] ? new Date(_data["changeDate"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): UpdateDebtorOnLocationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDebtorOnLocationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["debtorId"] = this.debtorId !== undefined ? this.debtorId : <any>null;
        data["debtorType"] = this.debtorType !== undefined ? this.debtorType : <any>null;
        data["changeDate"] = this.changeDate ? this.changeDate.toISOString() : <any>null;
        return data; 
    }
}

export interface IUpdateDebtorOnLocationCommand {
    locationId?: number;
    debtorId?: number;
    debtorType?: LocationDebtorType;
    changeDate?: Date | null;
}

export class RemoveDebtorFromLocationCommand implements IRemoveDebtorFromLocationCommand {
    locationId?: number;
    debtorId?: number;

    constructor(data?: IRemoveDebtorFromLocationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.debtorId = _data["debtorId"] !== undefined ? _data["debtorId"] : <any>null;
        }
    }

    static fromJS(data: any): RemoveDebtorFromLocationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveDebtorFromLocationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["debtorId"] = this.debtorId !== undefined ? this.debtorId : <any>null;
        return data; 
    }
}

export interface IRemoveDebtorFromLocationCommand {
    locationId?: number;
    debtorId?: number;
}

export class PageResultOfLocationDetailsIdDtoAndDateTimeOffset implements IPageResultOfLocationDetailsIdDtoAndDateTimeOffset {
    newNeedle?: Date;
    pagesRemaining?: number;
    results?: LocationDetailsIdDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfLocationDetailsIdDtoAndDateTimeOffset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] ? new Date(_data["newNeedle"].toString()) : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(LocationDetailsIdDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfLocationDetailsIdDtoAndDateTimeOffset {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfLocationDetailsIdDtoAndDateTimeOffset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle ? this.newNeedle.toISOString() : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfLocationDetailsIdDtoAndDateTimeOffset {
    newNeedle?: Date;
    pagesRemaining?: number;
    results?: LocationDetailsIdDto[] | null;
    hasMore?: boolean;
}

export class LocationDetailsIdDto extends LocationDetailsDto implements ILocationDetailsIdDto {
    id?: number;

    constructor(data?: ILocationDetailsIdDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): LocationDetailsIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDetailsIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ILocationDetailsIdDto extends ILocationDetailsDto {
    id?: number;
}

export class PageResultOfLocationHistoryDtoAndString implements IPageResultOfLocationHistoryDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: LocationHistoryDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfLocationHistoryDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new LocationHistoryDto(item) : <LocationHistoryDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(LocationHistoryDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfLocationHistoryDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfLocationHistoryDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfLocationHistoryDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: ILocationHistoryDto[] | null;
    hasMore?: boolean;
}

export class PageResultOfLocationHistoryDto extends PageResultOfLocationHistoryDtoAndString implements IPageResultOfLocationHistoryDto {

    constructor(data?: IPageResultOfLocationHistoryDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PageResultOfLocationHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfLocationHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPageResultOfLocationHistoryDto extends IPageResultOfLocationHistoryDtoAndString {
}

export class LocationHistoryDto implements ILocationHistoryDto {
    id?: number;
    regionId?: number;
    schedule?: RefillSchedule;
    address?: string | null;
    addressExtra?: string | null;
    comments?: string | null;
    locationId?: number;
    timeOfChange?: Date;

    constructor(data?: ILocationHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.schedule = _data["schedule"] !== undefined ? _data["schedule"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.addressExtra = _data["addressExtra"] !== undefined ? _data["addressExtra"] : <any>null;
            this.comments = _data["comments"] !== undefined ? _data["comments"] : <any>null;
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.timeOfChange = _data["timeOfChange"] ? new Date(_data["timeOfChange"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): LocationHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["schedule"] = this.schedule !== undefined ? this.schedule : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["addressExtra"] = this.addressExtra !== undefined ? this.addressExtra : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["timeOfChange"] = this.timeOfChange ? this.timeOfChange.toISOString() : <any>null;
        return data; 
    }
}

export interface ILocationHistoryDto {
    id?: number;
    regionId?: number;
    schedule?: RefillSchedule;
    address?: string | null;
    addressExtra?: string | null;
    comments?: string | null;
    locationId?: number;
    timeOfChange?: Date;
}

export class PageResultOfLocationDebtorHistoryDtoAndDateTime implements IPageResultOfLocationDebtorHistoryDtoAndDateTime {
    newNeedle?: Date;
    pagesRemaining?: number;
    results?: LocationDebtorHistoryDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfLocationDebtorHistoryDtoAndDateTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new LocationDebtorHistoryDto(item) : <LocationDebtorHistoryDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] ? new Date(_data["newNeedle"].toString()) : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(LocationDebtorHistoryDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfLocationDebtorHistoryDtoAndDateTime {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfLocationDebtorHistoryDtoAndDateTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle ? this.newNeedle.toISOString() : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfLocationDebtorHistoryDtoAndDateTime {
    newNeedle?: Date;
    pagesRemaining?: number;
    results?: ILocationDebtorHistoryDto[] | null;
    hasMore?: boolean;
}

export class LocationDebtorHistoryDto implements ILocationDebtorHistoryDto {
    locationId?: number;
    debtorId?: number;
    type?: LocationDebtorType;
    timeOfChange?: Date;

    constructor(data?: ILocationDebtorHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.debtorId = _data["debtorId"] !== undefined ? _data["debtorId"] : <any>null;
            this.type = _data["type"] !== undefined ? _data["type"] : <any>null;
            this.timeOfChange = _data["timeOfChange"] ? new Date(_data["timeOfChange"].toString()) : <any>null;
        }
    }

    static fromJS(data: any): LocationDebtorHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDebtorHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["debtorId"] = this.debtorId !== undefined ? this.debtorId : <any>null;
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["timeOfChange"] = this.timeOfChange ? this.timeOfChange.toISOString() : <any>null;
        return data; 
    }
}

export interface ILocationDebtorHistoryDto {
    locationId?: number;
    debtorId?: number;
    type?: LocationDebtorType;
    timeOfChange?: Date;
}

export class PageResultOfRefillDtoAndDateTimeOffset implements IPageResultOfRefillDtoAndDateTimeOffset {
    newNeedle?: Date;
    pagesRemaining?: number;
    results?: RefillDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfRefillDtoAndDateTimeOffset) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new RefillDto(item) : <RefillDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] ? new Date(_data["newNeedle"].toString()) : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RefillDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfRefillDtoAndDateTimeOffset {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfRefillDtoAndDateTimeOffset();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle ? this.newNeedle.toISOString() : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfRefillDtoAndDateTimeOffset {
    newNeedle?: Date;
    pagesRemaining?: number;
    results?: IRefillDto[] | null;
    hasMore?: boolean;
}

export class RefillDto implements IRefillDto {
    id?: number;
    expectedDeliveryDate?: Date;
    actualDeliveryDate?: Date;
    locationType?: TankType;
    couponId?: number;
    truckId?: number;
    startAmount?: number;
    endAmount?: number;

    constructor(data?: IRefillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.expectedDeliveryDate = _data["expectedDeliveryDate"] ? new Date(_data["expectedDeliveryDate"].toString()) : <any>null;
            this.actualDeliveryDate = _data["actualDeliveryDate"] ? new Date(_data["actualDeliveryDate"].toString()) : <any>null;
            this.locationType = _data["locationType"] !== undefined ? _data["locationType"] : <any>null;
            this.couponId = _data["couponId"] !== undefined ? _data["couponId"] : <any>null;
            this.truckId = _data["truckId"] !== undefined ? _data["truckId"] : <any>null;
            this.startAmount = _data["startAmount"] !== undefined ? _data["startAmount"] : <any>null;
            this.endAmount = _data["endAmount"] !== undefined ? _data["endAmount"] : <any>null;
        }
    }

    static fromJS(data: any): RefillDto {
        data = typeof data === 'object' ? data : {};
        let result = new RefillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["expectedDeliveryDate"] = this.expectedDeliveryDate ? this.expectedDeliveryDate.toISOString() : <any>null;
        data["actualDeliveryDate"] = this.actualDeliveryDate ? this.actualDeliveryDate.toISOString() : <any>null;
        data["locationType"] = this.locationType !== undefined ? this.locationType : <any>null;
        data["couponId"] = this.couponId !== undefined ? this.couponId : <any>null;
        data["truckId"] = this.truckId !== undefined ? this.truckId : <any>null;
        data["startAmount"] = this.startAmount !== undefined ? this.startAmount : <any>null;
        data["endAmount"] = this.endAmount !== undefined ? this.endAmount : <any>null;
        return data; 
    }
}

export interface IRefillDto {
    id?: number;
    expectedDeliveryDate?: Date;
    actualDeliveryDate?: Date;
    locationType?: TankType;
    couponId?: number;
    truckId?: number;
    startAmount?: number;
    endAmount?: number;
}

export class UpdateLocationMetaDataCommand implements IUpdateLocationMetaDataCommand {
    data?: LocationDetailsDto | null;

    constructor(data?: IUpdateLocationMetaDataCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.data = data.data && !(<any>data.data).toJSON ? new LocationDetailsDto(data.data) : <LocationDetailsDto>this.data; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? LocationDetailsDto.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateLocationMetaDataCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLocationMetaDataCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateLocationMetaDataCommand {
    data?: ILocationDetailsDto | null;
}

export class ImageResponseDto implements IImageResponseDto {
    locationId?: number;
    stream?: string | null;

    constructor(data?: IImageResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.stream = _data["stream"] !== undefined ? _data["stream"] : <any>null;
        }
    }

    static fromJS(data: any): ImageResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImageResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["stream"] = this.stream !== undefined ? this.stream : <any>null;
        return data; 
    }
}

export interface IImageResponseDto {
    locationId?: number;
    stream?: string | null;
}

export class CompleteRefillCommand implements ICompleteRefillCommand {
    startAmount?: number;
    endAmount?: number;
    couponNumber?: number;
    actualDeliveryDate?: Date;
    tankState?: TankState;

    constructor(data?: ICompleteRefillCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startAmount = _data["startAmount"] !== undefined ? _data["startAmount"] : <any>null;
            this.endAmount = _data["endAmount"] !== undefined ? _data["endAmount"] : <any>null;
            this.couponNumber = _data["couponNumber"] !== undefined ? _data["couponNumber"] : <any>null;
            this.actualDeliveryDate = _data["actualDeliveryDate"] ? new Date(_data["actualDeliveryDate"].toString()) : <any>null;
            this.tankState = _data["tankState"] !== undefined ? _data["tankState"] : <any>null;
        }
    }

    static fromJS(data: any): CompleteRefillCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteRefillCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startAmount"] = this.startAmount !== undefined ? this.startAmount : <any>null;
        data["endAmount"] = this.endAmount !== undefined ? this.endAmount : <any>null;
        data["couponNumber"] = this.couponNumber !== undefined ? this.couponNumber : <any>null;
        data["actualDeliveryDate"] = this.actualDeliveryDate ? this.actualDeliveryDate.toISOString() : <any>null;
        data["tankState"] = this.tankState !== undefined ? this.tankState : <any>null;
        return data; 
    }
}

export interface ICompleteRefillCommand {
    startAmount?: number;
    endAmount?: number;
    couponNumber?: number;
    actualDeliveryDate?: Date;
    tankState?: TankState;
}

export enum TankState {
    EMPTY = 0,
    FULL = 1,
    PARTIALLY_FILLED = 2,
}

export class PageResultOfRefillDtoAndString implements IPageResultOfRefillDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: RefillDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfRefillDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new RefillDto(item) : <RefillDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RefillDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfRefillDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfRefillDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfRefillDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: IRefillDto[] | null;
    hasMore?: boolean;
}

export class PageResultOfRefillDto extends PageResultOfRefillDtoAndString implements IPageResultOfRefillDto {

    constructor(data?: IPageResultOfRefillDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PageResultOfRefillDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfRefillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPageResultOfRefillDto extends IPageResultOfRefillDtoAndString {
}

export class CouponImageInfoDto implements ICouponImageInfoDto {
    refillId?: number;
    couponNumber?: number;
    path?: string | null;

    constructor(data?: ICouponImageInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refillId = _data["refillId"] !== undefined ? _data["refillId"] : <any>null;
            this.couponNumber = _data["couponNumber"] !== undefined ? _data["couponNumber"] : <any>null;
            this.path = _data["path"] !== undefined ? _data["path"] : <any>null;
        }
    }

    static fromJS(data: any): CouponImageInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CouponImageInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refillId"] = this.refillId !== undefined ? this.refillId : <any>null;
        data["couponNumber"] = this.couponNumber !== undefined ? this.couponNumber : <any>null;
        data["path"] = this.path !== undefined ? this.path : <any>null;
        return data; 
    }
}

export interface ICouponImageInfoDto {
    refillId?: number;
    couponNumber?: number;
    path?: string | null;
}

export class OrderRefillCommand implements IOrderRefillCommand {
    expectedDeliveryDate?: Date;
    locationId?: number;
    truckId?: number;

    constructor(data?: IOrderRefillCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.expectedDeliveryDate = _data["expectedDeliveryDate"] ? new Date(_data["expectedDeliveryDate"].toString()) : <any>null;
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.truckId = _data["truckId"] !== undefined ? _data["truckId"] : <any>null;
        }
    }

    static fromJS(data: any): OrderRefillCommand {
        data = typeof data === 'object' ? data : {};
        let result = new OrderRefillCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["expectedDeliveryDate"] = this.expectedDeliveryDate ? this.expectedDeliveryDate.toISOString() : <any>null;
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["truckId"] = this.truckId !== undefined ? this.truckId : <any>null;
        return data; 
    }
}

export interface IOrderRefillCommand {
    expectedDeliveryDate?: Date;
    locationId?: number;
    truckId?: number;
}

export class ImageResponseDto2 implements IImageResponseDto2 {
    stream?: string | null;
    refillId?: number;
    couponId?: number;

    constructor(data?: IImageResponseDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.stream = _data["stream"] !== undefined ? _data["stream"] : <any>null;
            this.refillId = _data["refillId"] !== undefined ? _data["refillId"] : <any>null;
            this.couponId = _data["couponId"] !== undefined ? _data["couponId"] : <any>null;
        }
    }

    static fromJS(data: any): ImageResponseDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new ImageResponseDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["stream"] = this.stream !== undefined ? this.stream : <any>null;
        data["refillId"] = this.refillId !== undefined ? this.refillId : <any>null;
        data["couponId"] = this.couponId !== undefined ? this.couponId : <any>null;
        return data; 
    }
}

export interface IImageResponseDto2 {
    stream?: string | null;
    refillId?: number;
    couponId?: number;
}

export class CreateRoleCommand implements ICreateRoleCommand {
    role?: RoleDto | null;

    constructor(data?: ICreateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.role = data.role && !(<any>data.role).toJSON ? new RoleDto(data.role) : <RoleDto>this.role; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>null;
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data; 
    }
}

export interface ICreateRoleCommand {
    role?: IRoleDto | null;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    role?: RoleDto | null;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.role = data.role && !(<any>data.role).toJSON ? new RoleDto(data.role) : <RoleDto>this.role; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleDto.fromJS(_data["role"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateRoleCommand {
    role?: IRoleDto | null;
}

export class PageResultOfRoleIdDtoAndString implements IPageResultOfRoleIdDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: RoleIdDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfRoleIdDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RoleIdDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfRoleIdDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfRoleIdDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfRoleIdDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: RoleIdDto[] | null;
    hasMore?: boolean;
}

export enum Interval {
    WEEK = 0,
    MONTH = 1,
    YEAR = 2,
}

export class FuelConsumptionDto implements IFuelConsumptionDto {
    address?: string | null;
    locationId?: number;
    startDate?: Date;
    endDate?: Date;
    fuelConsumed?: number;

    constructor(data?: IFuelConsumptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>null;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>null;
            this.fuelConsumed = _data["fuelConsumed"] !== undefined ? _data["fuelConsumed"] : <any>null;
        }
    }

    static fromJS(data: any): FuelConsumptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FuelConsumptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>null;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>null;
        data["fuelConsumed"] = this.fuelConsumed !== undefined ? this.fuelConsumed : <any>null;
        return data; 
    }
}

export interface IFuelConsumptionDto {
    address?: string | null;
    locationId?: number;
    startDate?: Date;
    endDate?: Date;
    fuelConsumed?: number;
}

export class PageResultOfStreetDtoAndString implements IPageResultOfStreetDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: StreetDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfStreetDtoAndString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            if (data.results) {
                this.results = [];
                for (let i = 0; i < data.results.length; i++) {
                    let item = data.results[i];
                    this.results[i] = item && !(<any>item).toJSON ? new StreetDto(item) : <StreetDto>item;
                }
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(StreetDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfStreetDtoAndString {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfStreetDtoAndString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfStreetDtoAndString {
    newNeedle?: string | null;
    pagesRemaining?: number;
    results?: IStreetDto[] | null;
    hasMore?: boolean;
}

export class PageResultOfStreetDto extends PageResultOfStreetDtoAndString implements IPageResultOfStreetDto {

    constructor(data?: IPageResultOfStreetDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): PageResultOfStreetDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfStreetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPageResultOfStreetDto extends IPageResultOfStreetDtoAndString {
}

export class StreetDto implements IStreetDto {
    id?: number;
    name?: string | null;
    regionId?: number;

    constructor(data?: IStreetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
        }
    }

    static fromJS(data: any): StreetDto {
        data = typeof data === 'object' ? data : {};
        let result = new StreetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        return data; 
    }
}

export interface IStreetDto {
    id?: number;
    name?: string | null;
    regionId?: number;
}

export class TruckInfoDto implements ITruckInfoDto {
    truckIdentifier?: string | null;
    name?: string | null;
    description?: string | null;
    tankCapacity?: number;
    refillNumber?: number;
    driverId?: number | null;

    constructor(data?: ITruckInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.truckIdentifier = _data["truckIdentifier"] !== undefined ? _data["truckIdentifier"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.description = _data["description"] !== undefined ? _data["description"] : <any>null;
            this.tankCapacity = _data["tankCapacity"] !== undefined ? _data["tankCapacity"] : <any>null;
            this.refillNumber = _data["refillNumber"] !== undefined ? _data["refillNumber"] : <any>null;
            this.driverId = _data["driverId"] !== undefined ? _data["driverId"] : <any>null;
        }
    }

    static fromJS(data: any): TruckInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TruckInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truckIdentifier"] = this.truckIdentifier !== undefined ? this.truckIdentifier : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["description"] = this.description !== undefined ? this.description : <any>null;
        data["tankCapacity"] = this.tankCapacity !== undefined ? this.tankCapacity : <any>null;
        data["refillNumber"] = this.refillNumber !== undefined ? this.refillNumber : <any>null;
        data["driverId"] = this.driverId !== undefined ? this.driverId : <any>null;
        return data; 
    }
}

export interface ITruckInfoDto {
    truckIdentifier?: string | null;
    name?: string | null;
    description?: string | null;
    tankCapacity?: number;
    refillNumber?: number;
    driverId?: number | null;
}

export class TruckInfoIdDto extends TruckInfoDto implements ITruckInfoIdDto {
    id?: number;

    constructor(data?: ITruckInfoIdDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
        }
    }

    static fromJS(data: any): TruckInfoIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new TruckInfoIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ITruckInfoIdDto extends ITruckInfoDto {
    id?: number;
}

export class TruckInfoDetailsDto extends TruckInfoIdDto implements ITruckInfoDetailsDto {
    currentTankLevel?: number;

    constructor(data?: ITruckInfoDetailsDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.currentTankLevel = _data["currentTankLevel"] !== undefined ? _data["currentTankLevel"] : <any>null;
        }
    }

    static fromJS(data: any): TruckInfoDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new TruckInfoDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentTankLevel"] = this.currentTankLevel !== undefined ? this.currentTankLevel : <any>null;
        super.toJSON(data);
        return data; 
    }
}

export interface ITruckInfoDetailsDto extends ITruckInfoIdDto {
    currentTankLevel?: number;
}

export class PageResultOfCouponIdDtoAndInteger implements IPageResultOfCouponIdDtoAndInteger {
    newNeedle?: number;
    pagesRemaining?: number;
    results?: CouponIdDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfCouponIdDtoAndInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CouponIdDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfCouponIdDtoAndInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfCouponIdDtoAndInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfCouponIdDtoAndInteger {
    newNeedle?: number;
    pagesRemaining?: number;
    results?: CouponIdDto[] | null;
    hasMore?: boolean;
}

export class PageResultOfTruckInfoIdDtoAndInteger implements IPageResultOfTruckInfoIdDtoAndInteger {
    newNeedle?: number;
    pagesRemaining?: number;
    results?: TruckInfoIdDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfTruckInfoIdDtoAndInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(TruckInfoIdDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfTruckInfoIdDtoAndInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfTruckInfoIdDtoAndInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfTruckInfoIdDtoAndInteger {
    newNeedle?: number;
    pagesRemaining?: number;
    results?: TruckInfoIdDto[] | null;
    hasMore?: boolean;
}

export class UpdateTruckCommand implements IUpdateTruckCommand {
    truckInfo?: TruckInfoDto | null;

    constructor(data?: IUpdateTruckCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.truckInfo = data.truckInfo && !(<any>data.truckInfo).toJSON ? new TruckInfoDto(data.truckInfo) : <TruckInfoDto>this.truckInfo; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.truckInfo = _data["truckInfo"] ? TruckInfoDto.fromJS(_data["truckInfo"]) : <any>null;
        }
    }

    static fromJS(data: any): UpdateTruckCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTruckCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truckInfo"] = this.truckInfo ? this.truckInfo.toJSON() : <any>null;
        return data; 
    }
}

export interface IUpdateTruckCommand {
    truckInfo?: ITruckInfoDto | null;
}

export class CreateTruckCommand implements ICreateTruckCommand {
    truckInfo?: TruckInfoDto | null;

    constructor(data?: ICreateTruckCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
            this.truckInfo = data.truckInfo && !(<any>data.truckInfo).toJSON ? new TruckInfoDto(data.truckInfo) : <TruckInfoDto>this.truckInfo; 
        }
    }

    init(_data?: any) {
        if (_data) {
            this.truckInfo = _data["truckInfo"] ? TruckInfoDto.fromJS(_data["truckInfo"]) : <any>null;
        }
    }

    static fromJS(data: any): CreateTruckCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTruckCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["truckInfo"] = this.truckInfo ? this.truckInfo.toJSON() : <any>null;
        return data; 
    }
}

export interface ICreateTruckCommand {
    truckInfo?: ITruckInfoDto | null;
}

export class LocationRefillDto implements ILocationRefillDto {
    refillId?: number;
    locationId?: number;
    regionId?: number;
    schedule?: RefillSchedule;
    locationType?: TankType;
    fuelType?: FuelType;
    address?: string | null;
    addressExtra?: string | null;
    expectedDeliveryDate?: Date;
    debtorBlocked?: boolean;
    couponRequired?: boolean;
    bstNumber?: string | null;
    comments?: string | null;

    constructor(data?: ILocationRefillDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.refillId = _data["refillId"] !== undefined ? _data["refillId"] : <any>null;
            this.locationId = _data["locationId"] !== undefined ? _data["locationId"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
            this.schedule = _data["schedule"] !== undefined ? _data["schedule"] : <any>null;
            this.locationType = _data["locationType"] !== undefined ? _data["locationType"] : <any>null;
            this.fuelType = _data["fuelType"] !== undefined ? _data["fuelType"] : <any>null;
            this.address = _data["address"] !== undefined ? _data["address"] : <any>null;
            this.addressExtra = _data["addressExtra"] !== undefined ? _data["addressExtra"] : <any>null;
            this.expectedDeliveryDate = _data["expectedDeliveryDate"] ? new Date(_data["expectedDeliveryDate"].toString()) : <any>null;
            this.debtorBlocked = _data["debtorBlocked"] !== undefined ? _data["debtorBlocked"] : <any>null;
            this.couponRequired = _data["couponRequired"] !== undefined ? _data["couponRequired"] : <any>null;
            this.bstNumber = _data["bstNumber"] !== undefined ? _data["bstNumber"] : <any>null;
            this.comments = _data["comments"] !== undefined ? _data["comments"] : <any>null;
        }
    }

    static fromJS(data: any): LocationRefillDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationRefillDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["refillId"] = this.refillId !== undefined ? this.refillId : <any>null;
        data["locationId"] = this.locationId !== undefined ? this.locationId : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        data["schedule"] = this.schedule !== undefined ? this.schedule : <any>null;
        data["locationType"] = this.locationType !== undefined ? this.locationType : <any>null;
        data["fuelType"] = this.fuelType !== undefined ? this.fuelType : <any>null;
        data["address"] = this.address !== undefined ? this.address : <any>null;
        data["addressExtra"] = this.addressExtra !== undefined ? this.addressExtra : <any>null;
        data["expectedDeliveryDate"] = this.expectedDeliveryDate ? this.expectedDeliveryDate.toISOString() : <any>null;
        data["debtorBlocked"] = this.debtorBlocked !== undefined ? this.debtorBlocked : <any>null;
        data["couponRequired"] = this.couponRequired !== undefined ? this.couponRequired : <any>null;
        data["bstNumber"] = this.bstNumber !== undefined ? this.bstNumber : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        return data; 
    }
}

export interface ILocationRefillDto {
    refillId?: number;
    locationId?: number;
    regionId?: number;
    schedule?: RefillSchedule;
    locationType?: TankType;
    fuelType?: FuelType;
    address?: string | null;
    addressExtra?: string | null;
    expectedDeliveryDate?: Date;
    debtorBlocked?: boolean;
    couponRequired?: boolean;
    bstNumber?: string | null;
    comments?: string | null;
}

export class CreateTruckRefillCommand implements ICreateTruckRefillCommand {
    timeStamp?: Date;
    fuelCardNumber?: number;
    amount?: number;
    fuelType?: FuelType;

    constructor(data?: ICreateTruckRefillCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>null;
            this.fuelCardNumber = _data["fuelCardNumber"] !== undefined ? _data["fuelCardNumber"] : <any>null;
            this.amount = _data["amount"] !== undefined ? _data["amount"] : <any>null;
            this.fuelType = _data["fuelType"] !== undefined ? _data["fuelType"] : <any>null;
        }
    }

    static fromJS(data: any): CreateTruckRefillCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTruckRefillCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>null;
        data["fuelCardNumber"] = this.fuelCardNumber !== undefined ? this.fuelCardNumber : <any>null;
        data["amount"] = this.amount !== undefined ? this.amount : <any>null;
        data["fuelType"] = this.fuelType !== undefined ? this.fuelType : <any>null;
        return data; 
    }
}

export interface ICreateTruckRefillCommand {
    timeStamp?: Date;
    fuelCardNumber?: number;
    amount?: number;
    fuelType?: FuelType;
}

export class CreateUserCommand implements ICreateUserCommand {
    userName?: string | null;
    password?: string | null;
    roleId?: number;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"] !== undefined ? _data["userName"] : <any>null;
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
            this.roleId = _data["roleId"] !== undefined ? _data["roleId"] : <any>null;
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName !== undefined ? this.userName : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["roleId"] = this.roleId !== undefined ? this.roleId : <any>null;
        return data; 
    }
}

export interface ICreateUserCommand {
    userName?: string | null;
    password?: string | null;
    roleId?: number;
}

export class UpdateUserRolesCommand implements IUpdateUserRolesCommand {
    role?: string | null;

    constructor(data?: IUpdateUserRolesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] !== undefined ? _data["role"] : <any>null;
        }
    }

    static fromJS(data: any): UpdateUserRolesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRolesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data; 
    }
}

export interface IUpdateUserRolesCommand {
    role?: string | null;
}

export class UpdatePasswordCommand implements IUpdatePasswordCommand {
    password?: string | null;

    constructor(data?: IUpdatePasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"] !== undefined ? _data["password"] : <any>null;
        }
    }

    static fromJS(data: any): UpdatePasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IUpdatePasswordCommand {
    password?: string | null;
}

export class PageResultOfUserIdDtoAndInteger implements IPageResultOfUserIdDtoAndInteger {
    newNeedle?: number;
    pagesRemaining?: number;
    results?: UserIdDto[] | null;
    hasMore?: boolean;

    constructor(data?: IPageResultOfUserIdDtoAndInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newNeedle = _data["newNeedle"] !== undefined ? _data["newNeedle"] : <any>null;
            this.pagesRemaining = _data["pagesRemaining"] !== undefined ? _data["pagesRemaining"] : <any>null;
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UserIdDto.fromJS(item));
            }
            this.hasMore = _data["hasMore"] !== undefined ? _data["hasMore"] : <any>null;
        }
    }

    static fromJS(data: any): PageResultOfUserIdDtoAndInteger {
        data = typeof data === 'object' ? data : {};
        let result = new PageResultOfUserIdDtoAndInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newNeedle"] = this.newNeedle !== undefined ? this.newNeedle : <any>null;
        data["pagesRemaining"] = this.pagesRemaining !== undefined ? this.pagesRemaining : <any>null;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        data["hasMore"] = this.hasMore !== undefined ? this.hasMore : <any>null;
        return data; 
    }
}

export interface IPageResultOfUserIdDtoAndInteger {
    newNeedle?: number;
    pagesRemaining?: number;
    results?: UserIdDto[] | null;
    hasMore?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

/* istanbul ignore file */